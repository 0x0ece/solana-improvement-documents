---
simd: 'XXXX'
title: Syscall for verifying secp256r1 signatures
authors:
  - SirIsaac (Bunkr)
  - Jstnw (Bunkr)
category: Standard
type: Core
status: Draft
created: 2023-05-14
feature: (fill in with feature tracking issues once accepted)
---

## Summary

Adding a Syscall to support the verification of sigatures generated on the secp256r1 curve. 
Similar to the support for secp256k1 signatures that already exists in form of the `KeccakSecp256k11111111111111111111111111111` native program an the `secp256k1_recover` syscall.

## Motivation

Solana should have option to secure your funds in a self custodial manner that doesn't just airgap your private key with a hardware wallet (which even then remains as a single point of failure). Arguably, multi-signature wallets fit into this equation as they enable the dependency on multiple private keys. However in practice the UX takes too much of a hit, as having to sign a transaction a minimum of 3 seperate times and having to write down 3 seed phrases is too cumbersome. It would be ideal to have an authetication form that relies on a more familiar and  second factor, such as a users mobile device.

Passkeys & WebAuthn are a standardized implementation of this. They enable users to save keypairs associated to different services natively on the secure element of their mobile device. To authenticate with those services, the user uses their biometrics to sign a message generated by the service with the associated private key. And although this is meant to enable password-less logins in web2, it makes for an excellent canditate as a second factor of authentication for our web3 puposes.

Going past just securing funds, this would support other beneficial account abstractions that make use of the simple UX of WebAuthn and Passkeys.

Note:

General Documentation:
[WebAuthn](https://webauthn.io/)
[Passkeys](https://fidoalliance.org/passkeys/)

## Alternatives Considered
We have discussed the following alternatives:

1.) Realising signature verification with a native program/instruction similar to `KeccakSecp256k11111111111111111111111111111` instead of a syscall. As the signature is known/generated by the user upfront for a tx, an implementation as a native program would also work.

## New Terminology

None

## Detailed Design

Initial direction would be as follows:

### Function: Â´fn secp256r1_verify(pubkey: &[u8], message: &[u8], signature: &[u8]) -> Result<(), Secp256r1Error>
Should be analog to what exists for secp256k1, except without `recovery_id`. It would enable verifying one signature at a time.

### Implementation
The crates `ecdsa` and `p256` are a good starting point for the implementation. Due to a current dependency version conflict of `zeroize` between `curve25519-dalek` and the `solana-program`, using these crates will require a fix/bump of `curve25519-dalek` See issue [#26688](https://github.com/solana-labs/solana/issues/26688)


## Impact

General outcome would be to enable implementing the on-chain usage of Passkeys and the WebAuthn Standard. These work primarily with secp256r1 keypairs that can be stored and used natively from within the secure elements of both IOS & Android devices.

By extension this would enable the creation of account abstractions and forms of Two-Factor Authentication around those keypairs.

## Security Considerations

- Ensure parity with tests and parameters in [SEC2](https://www.secg.org/sec2-v2.pdf) for the secp256r1 curve
- Ensure signature malleability is prevented/accounted for

## Backwards Compatibility

Programs using the syscall could not be used on Solana versions which don't implement this feature. A Feature gate should be used to enable this feature when the majority of the cluster is using the required version. Existing programs that do not use this feature are not impacted.
